var CodeMirror = require("codemirror");
CodeMirror.defineMode("glsl", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || {},
        builtins = parserConfig.builtins || {},
        blockKeywords = parserConfig.blockKeywords || {},
        atoms = parserConfig.atoms || {},
        hooks = parserConfig.hooks || {},
        multiLineStrings = parserConfig.multiLineStrings;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;
  
    var curPunc;
  
    function tokenBase(stream, state) {
      if (state.startOfLine) { delete state.type2; state.tinc = 0;}
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if(state.type2 && state.tinc && ch !== "<" && ch !== ">") {
        stream.eatWhile(/:\w\.\//);
        return "link";
      }
      if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        curPunc = ch;
        return "bracket";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\#\w\$_]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(cur)) {
        return "builtin";
      }
      if (atoms.propertyIsEnumerable(cur)) return "atom";
      
      if(cur[0] === "@") {
        return "link nslink";
      }
      if(cur[0] === "#") { 
        state.type2 = cur;  return "atom"; 
      } else if(state.type2 && state.type2 in {"#video":1, "#image":1, "#cube":1, "#import":1, "#track":1, "#net":1}){ 
        //console.log(cur, state.context.type, state.type2, ++state.tinc);
        state.tinc++;
      }
      return "word";
    }
  
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) {end = true; break;}
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = tokenBase;
        return "string";
      };
    }
  
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }
  
    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      return state.context = new Context(state.indented, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }
  
    // Interface
  
    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },
  
      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (ctx.align == null) ctx.align = true;
        if (style == "comment" || style == "meta") return style;
        if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
          pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },
  
      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null) return 0;
        var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
        if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
        else if (ctx.align) return ctx.column + (closing ? 0 : 1);
        else return ctx.indented + (closing ? 0 : indentUnit);
      },
  
      electricChars: "{}",
      fold: "brace"
    };
  });
  
  (function() {
    function words(str) {
      var obj = {}, words = str.split(" ");
      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
      return obj;
    }
    var glslKeywords = "const uniform break continue " +
      "do for while if else switch case in out inout float int uint void bool true false " +
      "invariant discard return mat2 mat3 mat2x2 mat2x3 mat2x4 mat3x2 mat3x3 mat3x4 mat2x4 mat4x3 mat4x4 " +
      "mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 uvec2 uvec3 uvec4 bvec2 bvec3 bvec4 sampler2D " +
      "samplerCube sampler3D struct";
    var glslBuiltins = "iTime iDelta iFrame iPass iFace iMouse iBoom iTrack iView iPad0 iPad1 iPad2 iPad3 iRes radians degrees sin cos tan asin acos atan pow sinh cosh tanh asinh acosh atanh " +
      "exp log exp2 log2 sqrt inversesqrt abs sign floor ceil round trunc fract mod modf " +
      "min max clamp mix step smoothstep length distance dot cross " +
      "determinant inverse normalize faceforward reflect refract matrixCompMult outerProduct transpose lessThan " +
      "lessThanEqual greaterThan greaterThanEqual equal notEqual any all not packUnorm2x16 unpackUnorm2x16 packSnorm2x16 unpackSnorm2x16 packHalf2x16 unpackHalf2x16 " +
      "dFdx dFdy fwidth textureSize texture textureProj textureLod textureGrad texelFetch texelFetchOffset " +
      "textureProjLod textureLodOffset textureGradOffset textureProjLodOffset textureProjGrad intBitsToFloat uintBitsToFloat floatBitsToInt floatBitsToUint isnan isinf";
  
    function cppHook(stream, state) {
      if (!state.startOfLine) return false;
      stream.skipToEnd();
      return "meta";
    }
  
    // C#-style strings where "" escapes a quote.
    function tokenAtString(stream, state) {
      var next;
      while ((next = stream.next()) != null) {
        if (next == '"' && !stream.eat('"')) {
          state.tokenize = null;
          break;
        }
      }
      return "string";
    }
  
    CodeMirror.defineMIME("text/x-glsl", {
      name: "glsl",
      keywords: words(glslKeywords),
      builtins: words(glslBuiltins),
      blockKeywords: words("case do else for if switch while struct"),
      atoms: words("null")
    });
  }());